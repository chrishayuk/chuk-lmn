Token(LmnTokenType.COMMENT,  test_functions_with_named.lmn)
Token(LmnTokenType.COMMENT,  -------------------------)
Token(LmnTokenType.COMMENT,  1) Implicitly typed function: add(a, b))
Token(LmnTokenType.COMMENT,     Demonstrates the use of positional and named arguments.)
Token(LmnTokenType.COMMENT,  -------------------------)
Token(LmnTokenType.FUNCTION, function)
Token(LmnTokenType.IDENTIFIER, add)
Token(LmnTokenType.LPAREN, ()
Token(LmnTokenType.IDENTIFIER, a)
Token(LmnTokenType.COMMA, ,)
Token(LmnTokenType.IDENTIFIER, b)
Token(LmnTokenType.RPAREN, ))
Token(LmnTokenType.COMMENT,  Return the sum of 'a' and 'b')
Token(LmnTokenType.RETURN, return)
Token(LmnTokenType.IDENTIFIER, a)
Token(LmnTokenType.PLUS, +)
Token(LmnTokenType.IDENTIFIER, b)
Token(LmnTokenType.END, end)
Token(LmnTokenType.COMMENT,  -------------------------)
Token(LmnTokenType.COMMENT,  1.1) Another implicitly typed function: subtract(a, b))
Token(LmnTokenType.COMMENT,       This one isn't commutative, so reversing 'a' and 'b')
Token(LmnTokenType.COMMENT,       will cause a different resultâ€”helpful to demonstrate)
Token(LmnTokenType.COMMENT,       correct vs. incorrect usage/order of arguments.)
Token(LmnTokenType.COMMENT,  -------------------------)
Token(LmnTokenType.FUNCTION, function)
Token(LmnTokenType.IDENTIFIER, subtract)
Token(LmnTokenType.LPAREN, ()
Token(LmnTokenType.IDENTIFIER, a)
Token(LmnTokenType.COMMA, ,)
Token(LmnTokenType.IDENTIFIER, b)
Token(LmnTokenType.RPAREN, ))
Token(LmnTokenType.RETURN, return)
Token(LmnTokenType.IDENTIFIER, a)
Token(LmnTokenType.MINUS, -)
Token(LmnTokenType.IDENTIFIER, b)
Token(LmnTokenType.END, end)
Token(LmnTokenType.COMMENT,  -------------------------)
Token(LmnTokenType.COMMENT,  2) Type-annotated function)
Token(LmnTokenType.COMMENT,     factorial(n: int) -> int)
Token(LmnTokenType.COMMENT,  -------------------------)
Token(LmnTokenType.FUNCTION, function)
Token(LmnTokenType.IDENTIFIER, factorial)
Token(LmnTokenType.LPAREN, ()
Token(LmnTokenType.IDENTIFIER, n)
Token(LmnTokenType.COLON, :)
Token(LmnTokenType.INT, int)
Token(LmnTokenType.RPAREN, ))
Token(LmnTokenType.COLON, :)
Token(LmnTokenType.INT, int)
Token(LmnTokenType.COMMENT,  If n <= 1, return 1)
Token(LmnTokenType.IF, if)
Token(LmnTokenType.IDENTIFIER, n)
Token(LmnTokenType.LE, <=)
Token(LmnTokenType.INT_LITERAL, 1)
Token(LmnTokenType.RETURN, return)
Token(LmnTokenType.INT_LITERAL, 1)
Token(LmnTokenType.ELSE, else)
Token(LmnTokenType.COMMENT,  Otherwise, factorial(n) = n * factorial(n - 1))
Token(LmnTokenType.RETURN, return)
Token(LmnTokenType.IDENTIFIER, n)
Token(LmnTokenType.MUL, *)
Token(LmnTokenType.IDENTIFIER, factorial)
Token(LmnTokenType.LPAREN, ()
Token(LmnTokenType.IDENTIFIER, n)
Token(LmnTokenType.MINUS, -)
Token(LmnTokenType.INT_LITERAL, 1)
Token(LmnTokenType.RPAREN, ))
Token(LmnTokenType.END, end)
Token(LmnTokenType.END, end)
Token(LmnTokenType.COMMENT,  -------------------------)
Token(LmnTokenType.COMMENT,  3) Type-annotated function returning a string)
Token(LmnTokenType.COMMENT,  -------------------------)
Token(LmnTokenType.FUNCTION, function)
Token(LmnTokenType.IDENTIFIER, even_or_odd)
Token(LmnTokenType.LPAREN, ()
Token(LmnTokenType.IDENTIFIER, x)
Token(LmnTokenType.COLON, :)
Token(LmnTokenType.INT, int)
Token(LmnTokenType.RPAREN, ))
Token(LmnTokenType.COLON, :)
Token(LmnTokenType.STRING_TYPE, string)
Token(LmnTokenType.COMMENT,  Use modulo to check if x is even or odd)
Token(LmnTokenType.IF, if)
Token(LmnTokenType.LPAREN, ()
Token(LmnTokenType.IDENTIFIER, x)
Token(LmnTokenType.MOD, %)
Token(LmnTokenType.INT_LITERAL, 2)
Token(LmnTokenType.RPAREN, ))
Token(LmnTokenType.EQEQ, ==)
Token(LmnTokenType.INT_LITERAL, 0)
Token(LmnTokenType.RETURN, return)
Token(LmnTokenType.STRING, even)
Token(LmnTokenType.ELSE, else)
Token(LmnTokenType.RETURN, return)
Token(LmnTokenType.STRING, odd)
Token(LmnTokenType.END, end)
Token(LmnTokenType.END, end)
Token(LmnTokenType.COMMENT,  -------------------------)
Token(LmnTokenType.COMMENT,  4) Main function (with type annotation))
Token(LmnTokenType.COMMENT,     main() -> int)
Token(LmnTokenType.COMMENT,  -------------------------)
Token(LmnTokenType.FUNCTION, function)
Token(LmnTokenType.IDENTIFIER, main)
Token(LmnTokenType.LPAREN, ()
Token(LmnTokenType.RPAREN, ))
Token(LmnTokenType.COLON, :)
Token(LmnTokenType.INT, int)
Token(LmnTokenType.COMMENT,  4.1) Demonstrate positional vs. named arguments with 'add')
Token(LmnTokenType.LET, let)
Token(LmnTokenType.IDENTIFIER, x)
Token(LmnTokenType.EQ, =)
Token(LmnTokenType.INT_LITERAL, 3)
Token(LmnTokenType.LET, let)
Token(LmnTokenType.IDENTIFIER, y)
Token(LmnTokenType.EQ, =)
Token(LmnTokenType.INT_LITERAL, 5)
Token(LmnTokenType.COMMENT,  4.1.1) Positional arguments (3 and 5 in order))
Token(LmnTokenType.PRINT, print)
Token(LmnTokenType.STRING, add()
Token(LmnTokenType.IDENTIFIER, x)
Token(LmnTokenType.STRING, ,)
Token(LmnTokenType.IDENTIFIER, y)
Token(LmnTokenType.STRING, ) [positional] = )
Token(LmnTokenType.IDENTIFIER, add)
Token(LmnTokenType.LPAREN, ()
Token(LmnTokenType.IDENTIFIER, x)
Token(LmnTokenType.COMMA, ,)
Token(LmnTokenType.IDENTIFIER, y)
Token(LmnTokenType.RPAREN, ))
Token(LmnTokenType.COMMENT,  4.1.2) Named arguments (matching parameter names in order))
Token(LmnTokenType.PRINT, print)
Token(LmnTokenType.STRING, add(a=)
Token(LmnTokenType.IDENTIFIER, x)
Token(LmnTokenType.STRING, , b=)
Token(LmnTokenType.IDENTIFIER, y)
Token(LmnTokenType.STRING, ) [named] = )
Token(LmnTokenType.IDENTIFIER, add)
Token(LmnTokenType.LPAREN, ()
Token(LmnTokenType.IDENTIFIER, a)
Token(LmnTokenType.EQ, =)
Token(LmnTokenType.IDENTIFIER, x)
Token(LmnTokenType.COMMA, ,)
Token(LmnTokenType.IDENTIFIER, b)
Token(LmnTokenType.EQ, =)
Token(LmnTokenType.IDENTIFIER, y)
Token(LmnTokenType.RPAREN, ))
Token(LmnTokenType.COMMENT,  4.1.3) Named arguments but swapped)
Token(LmnTokenType.PRINT, print)
Token(LmnTokenType.STRING, add(b=)
Token(LmnTokenType.IDENTIFIER, y)
Token(LmnTokenType.STRING, , a=)
Token(LmnTokenType.IDENTIFIER, x)
Token(LmnTokenType.STRING, ) [named out of order] = )
Token(LmnTokenType.IDENTIFIER, add)
Token(LmnTokenType.LPAREN, ()
Token(LmnTokenType.IDENTIFIER, b)
Token(LmnTokenType.EQ, =)
Token(LmnTokenType.IDENTIFIER, y)
Token(LmnTokenType.COMMA, ,)
Token(LmnTokenType.IDENTIFIER, a)
Token(LmnTokenType.EQ, =)
Token(LmnTokenType.IDENTIFIER, x)
Token(LmnTokenType.RPAREN, ))
Token(LmnTokenType.COMMENT,  4.2) Show how reversing arguments can be "wrong" in certain functions)
Token(LmnTokenType.COMMENT,       We'll use our new 'subtract(a, b)' function)
Token(LmnTokenType.LET, let)
Token(LmnTokenType.IDENTIFIER, p)
Token(LmnTokenType.EQ, =)
Token(LmnTokenType.INT_LITERAL, 3)
Token(LmnTokenType.LET, let)
Token(LmnTokenType.IDENTIFIER, q)
Token(LmnTokenType.EQ, =)
Token(LmnTokenType.INT_LITERAL, 5)
Token(LmnTokenType.COMMENT,  sub(3,5) is -2)
Token(LmnTokenType.PRINT, print)
Token(LmnTokenType.STRING, subtract()
Token(LmnTokenType.IDENTIFIER, p)
Token(LmnTokenType.STRING, ,)
Token(LmnTokenType.IDENTIFIER, q)
Token(LmnTokenType.STRING, ) [positional] = )
Token(LmnTokenType.IDENTIFIER, subtract)
Token(LmnTokenType.LPAREN, ()
Token(LmnTokenType.IDENTIFIER, p)
Token(LmnTokenType.COMMA, ,)
Token(LmnTokenType.IDENTIFIER, q)
Token(LmnTokenType.RPAREN, ))
Token(LmnTokenType.COMMENT,  sub(5,3) is 2)
Token(LmnTokenType.PRINT, print)
Token(LmnTokenType.STRING, subtract()
Token(LmnTokenType.IDENTIFIER, q)
Token(LmnTokenType.STRING, ,)
Token(LmnTokenType.IDENTIFIER, p)
Token(LmnTokenType.STRING, ) [positional swapped] = )
Token(LmnTokenType.IDENTIFIER, subtract)
Token(LmnTokenType.LPAREN, ()
Token(LmnTokenType.IDENTIFIER, q)
Token(LmnTokenType.COMMA, ,)
Token(LmnTokenType.IDENTIFIER, p)
Token(LmnTokenType.RPAREN, ))
Token(LmnTokenType.COMMENT,  Named arguments in original order => subtract(a=3, b=5))
Token(LmnTokenType.PRINT, print)
Token(LmnTokenType.STRING, subtract(a=)
Token(LmnTokenType.IDENTIFIER, p)
Token(LmnTokenType.STRING, , b=)
Token(LmnTokenType.IDENTIFIER, q)
Token(LmnTokenType.STRING, ) [named] = )
Token(LmnTokenType.IDENTIFIER, subtract)
Token(LmnTokenType.LPAREN, ()
Token(LmnTokenType.IDENTIFIER, a)
Token(LmnTokenType.EQ, =)
Token(LmnTokenType.IDENTIFIER, p)
Token(LmnTokenType.COMMA, ,)
Token(LmnTokenType.IDENTIFIER, b)
Token(LmnTokenType.EQ, =)
Token(LmnTokenType.IDENTIFIER, q)
Token(LmnTokenType.RPAREN, ))
Token(LmnTokenType.COMMENT,  Named arguments swapped => subtract(b=3, a=5))
Token(LmnTokenType.COMMENT,  This is effectively 5 - 3 = 2, which may be "wrong" depending on your intention)
Token(LmnTokenType.PRINT, print)
Token(LmnTokenType.STRING, subtract(b=)
Token(LmnTokenType.IDENTIFIER, p)
Token(LmnTokenType.STRING, , a=)
Token(LmnTokenType.IDENTIFIER, q)
Token(LmnTokenType.STRING, ) [named out of order] = )
Token(LmnTokenType.IDENTIFIER, subtract)
Token(LmnTokenType.LPAREN, ()
Token(LmnTokenType.IDENTIFIER, b)
Token(LmnTokenType.EQ, =)
Token(LmnTokenType.IDENTIFIER, p)
Token(LmnTokenType.COMMA, ,)
Token(LmnTokenType.IDENTIFIER, a)
Token(LmnTokenType.EQ, =)
Token(LmnTokenType.IDENTIFIER, q)
Token(LmnTokenType.RPAREN, ))
Token(LmnTokenType.COMMENT,  4.3) Test the type-annotated 'factorial' function)
Token(LmnTokenType.LET, let)
Token(LmnTokenType.IDENTIFIER, n)
Token(LmnTokenType.EQ, =)
Token(LmnTokenType.INT_LITERAL, 5)
Token(LmnTokenType.COMMENT,  Factorial with positional argument)
Token(LmnTokenType.PRINT, print)
Token(LmnTokenType.STRING, factorial()
Token(LmnTokenType.IDENTIFIER, n)
Token(LmnTokenType.STRING, ) [positional] = )
Token(LmnTokenType.IDENTIFIER, factorial)
Token(LmnTokenType.LPAREN, ()
Token(LmnTokenType.IDENTIFIER, n)
Token(LmnTokenType.RPAREN, ))
Token(LmnTokenType.COMMENT,  Factorial with named argument)
Token(LmnTokenType.PRINT, print)
Token(LmnTokenType.STRING, factorial(n=)
Token(LmnTokenType.IDENTIFIER, n)
Token(LmnTokenType.STRING, ) [named] = )
Token(LmnTokenType.IDENTIFIER, factorial)
Token(LmnTokenType.LPAREN, ()
Token(LmnTokenType.IDENTIFIER, n)
Token(LmnTokenType.EQ, =)
Token(LmnTokenType.IDENTIFIER, n)
Token(LmnTokenType.RPAREN, ))
Token(LmnTokenType.COMMENT,  4.4) Show if a number is even or odd using 'even_or_odd')
Token(LmnTokenType.LET, let)
Token(LmnTokenType.IDENTIFIER, z)
Token(LmnTokenType.EQ, =)
Token(LmnTokenType.INT_LITERAL, 10)
Token(LmnTokenType.PRINT, print)
Token(LmnTokenType.IDENTIFIER, z)
Token(LmnTokenType.STRING,  is )
Token(LmnTokenType.IDENTIFIER, even_or_odd)
Token(LmnTokenType.LPAREN, ()
Token(LmnTokenType.IDENTIFIER, z)
Token(LmnTokenType.RPAREN, ))
Token(LmnTokenType.COMMENT,  4.5) Another quick check on an odd input)
Token(LmnTokenType.LET, let)
Token(LmnTokenType.IDENTIFIER, w)
Token(LmnTokenType.EQ, =)
Token(LmnTokenType.INT_LITERAL, 7)
Token(LmnTokenType.PRINT, print)
Token(LmnTokenType.IDENTIFIER, w)
Token(LmnTokenType.STRING,  is )
Token(LmnTokenType.IDENTIFIER, even_or_odd)
Token(LmnTokenType.LPAREN, ()
Token(LmnTokenType.IDENTIFIER, w)
Token(LmnTokenType.RPAREN, ))
Token(LmnTokenType.COMMENT,  Return 0 from main)
Token(LmnTokenType.RETURN, return)
Token(LmnTokenType.INT_LITERAL, 0)
Token(LmnTokenType.END, end)
