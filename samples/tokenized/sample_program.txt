Token(LmnTokenType.COMMENT,  file: 09_mix_features.lmn)
Token(LmnTokenType.COMMENT,  A simple function 'foo' that takes one integer param 'n' and returns 2*n)
Token(LmnTokenType.FUNCTION, function)
Token(LmnTokenType.IDENTIFIER, foo)
Token(LmnTokenType.LPAREN, ()
Token(LmnTokenType.IDENTIFIER, n)
Token(LmnTokenType.COLON, :)
Token(LmnTokenType.INT, int)
Token(LmnTokenType.RPAREN, ))
Token(LmnTokenType.RETURN, return)
Token(LmnTokenType.IDENTIFIER, n)
Token(LmnTokenType.MUL, *)
Token(LmnTokenType.INT_LITERAL, 2)
Token(LmnTokenType.END, end)
Token(LmnTokenType.COMMENT,  Another function that takes a typed array of int.)
Token(LmnTokenType.COMMENT,  Since 'for' loops aren't implemented yet, we'll just return 0 for now.)
Token(LmnTokenType.FUNCTION, function)
Token(LmnTokenType.IDENTIFIER, typedDouble)
Token(LmnTokenType.LPAREN, ()
Token(LmnTokenType.IDENTIFIER, nums)
Token(LmnTokenType.COLON, :)
Token(LmnTokenType.INT, int)
Token(LmnTokenType.LBRACKET, [)
Token(LmnTokenType.RBRACKET, ])
Token(LmnTokenType.RPAREN, ))
Token(LmnTokenType.COMMENT,  Future: you could sum or process 'nums' if you had loops / indexing)
Token(LmnTokenType.RETURN, return)
Token(LmnTokenType.INT_LITERAL, 0)
Token(LmnTokenType.END, end)
Token(LmnTokenType.FUNCTION, function)
Token(LmnTokenType.IDENTIFIER, main)
Token(LmnTokenType.LPAREN, ()
Token(LmnTokenType.RPAREN, ))
Token(LmnTokenType.COMMENT,  1) A simple string with an emoji and some escapes)
Token(LmnTokenType.LET, let)
Token(LmnTokenType.IDENTIFIER, greeting)
Token(LmnTokenType.EQ, =)
Token(LmnTokenType.STRING, Hello\nðŸŒ \"Earth\"!)
Token(LmnTokenType.COMMENT,  Print it)
Token(LmnTokenType.PRINT, print)
Token(LmnTokenType.IDENTIFIER, greeting)
Token(LmnTokenType.COMMENT,  2) A JSON object literal (untyped => 'json'))
Token(LmnTokenType.LET, let)
Token(LmnTokenType.IDENTIFIER, user)
Token(LmnTokenType.EQ, =)
Token(LmnTokenType.LBRACE, {)
Token(LmnTokenType.STRING, name)
Token(LmnTokenType.COLON, :)
Token(LmnTokenType.STRING, Alice)
Token(LmnTokenType.COMMA, ,)
Token(LmnTokenType.STRING, age)
Token(LmnTokenType.COLON, :)
Token(LmnTokenType.INT_LITERAL, 42)
Token(LmnTokenType.COMMA, ,)
Token(LmnTokenType.STRING, languages)
Token(LmnTokenType.COLON, :)
Token(LmnTokenType.LBRACKET, [)
Token(LmnTokenType.STRING, English)
Token(LmnTokenType.COMMA, ,)
Token(LmnTokenType.STRING, Spanish)
Token(LmnTokenType.RBRACKET, ])
Token(LmnTokenType.COMMA, ,)
Token(LmnTokenType.STRING, active)
Token(LmnTokenType.COLON, :)
Token(LmnTokenType.TRUE, true)
Token(LmnTokenType.RBRACE, })
Token(LmnTokenType.PRINT, print)
Token(LmnTokenType.STRING, User data:)
Token(LmnTokenType.IDENTIFIER, user)
Token(LmnTokenType.COMMENT,  3) A strict JSON array => 'json')
Token(LmnTokenType.LET, let)
Token(LmnTokenType.IDENTIFIER, colors)
Token(LmnTokenType.EQ, =)
Token(LmnTokenType.LBRACKET, [)
Token(LmnTokenType.STRING, red)
Token(LmnTokenType.COMMA, ,)
Token(LmnTokenType.STRING, green)
Token(LmnTokenType.COMMA, ,)
Token(LmnTokenType.STRING, blue)
Token(LmnTokenType.RBRACKET, ])
Token(LmnTokenType.PRINT, print)
Token(LmnTokenType.STRING, Colors array:)
Token(LmnTokenType.IDENTIFIER, colors)
Token(LmnTokenType.COMMENT,  4) A typed array of int. No 'for' loop to process it, but we can pass it to typedDouble(...))
Token(LmnTokenType.LET, let)
Token(LmnTokenType.IDENTIFIER, typedNums)
Token(LmnTokenType.COLON, :)
Token(LmnTokenType.INT, int)
Token(LmnTokenType.LBRACKET, [)
Token(LmnTokenType.RBRACKET, ])
Token(LmnTokenType.EQ, =)
Token(LmnTokenType.LBRACKET, [)
Token(LmnTokenType.INT_LITERAL, 1)
Token(LmnTokenType.COMMA, ,)
Token(LmnTokenType.INT_LITERAL, 2)
Token(LmnTokenType.COMMA, ,)
Token(LmnTokenType.INT_LITERAL, 3)
Token(LmnTokenType.COMMA, ,)
Token(LmnTokenType.INT_LITERAL, 10)
Token(LmnTokenType.RBRACKET, ])
Token(LmnTokenType.PRINT, print)
Token(LmnTokenType.STRING, typedNums is)
Token(LmnTokenType.IDENTIFIER, typedNums)
Token(LmnTokenType.PRINT, print)
Token(LmnTokenType.STRING, typedDouble(typedNums) =>)
Token(LmnTokenType.IDENTIFIER, typedDouble)
Token(LmnTokenType.LPAREN, ()
Token(LmnTokenType.IDENTIFIER, typedNums)
Token(LmnTokenType.RPAREN, ))
Token(LmnTokenType.COMMENT,  5) A native array with arbitrary expressions (untyped => 'any[]' or 'array'))
Token(LmnTokenType.COMMENT,     includes an arithmetic expr (2+3) and a call to foo(7))
Token(LmnTokenType.LET, let)
Token(LmnTokenType.IDENTIFIER, myArray)
Token(LmnTokenType.EQ, =)
Token(LmnTokenType.LBRACKET, [)
Token(LmnTokenType.INT_LITERAL, 1)
Token(LmnTokenType.COMMA, ,)
Token(LmnTokenType.INT_LITERAL, 2)
Token(LmnTokenType.PLUS, +)
Token(LmnTokenType.INT_LITERAL, 3)
Token(LmnTokenType.COMMA, ,)
Token(LmnTokenType.IDENTIFIER, foo)
Token(LmnTokenType.LPAREN, ()
Token(LmnTokenType.INT_LITERAL, 7)
Token(LmnTokenType.RPAREN, ))
Token(LmnTokenType.COMMA, ,)
Token(LmnTokenType.IDENTIFIER, greeting)
Token(LmnTokenType.RBRACKET, ])
Token(LmnTokenType.PRINT, print)
Token(LmnTokenType.STRING, Native array with expressions:)
Token(LmnTokenType.IDENTIFIER, myArray)
Token(LmnTokenType.END, end)
